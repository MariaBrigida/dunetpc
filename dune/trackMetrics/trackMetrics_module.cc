////////////////////////////////////////////////////////////////////////
// Class:       trackMetrics
// Plugin Type: analyzer (art v3_05_01)
// File:        trackMetrics_module.cc
//
// Generated by Maria Brigida Brunetti using cetskelgen
// from cetlib version v3_10_00.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "art_root_io/TFileService.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "lardataobj/RecoBase/PFParticle.h"
#include "lardataobj/AnalysisBase/Calorimetry.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RecoBase/Cluster.h"
#include "lardataobj/RecoBase/Shower.h"
#include "lardataobj/RecoBase/Hit.h"
#include "larcore/Geometry/Geometry.h"
#include "lardata/ArtDataHelper/TrackUtils.h"

#include "dune/AnaUtils/DUNEAnaEventUtils.h"
#include "dune/AnaUtils/DUNEAnaPFParticleUtils.h"


#include <TTree.h>
#include <vector>
#include <string>
#include <TH1D.h>
#include <TH2D.h>


namespace test {
  class trackMetrics;
}


class test::trackMetrics : public art::EDAnalyzer {
public:
  explicit trackMetrics(fhicl::ParameterSet const& p);
  // The compiler-generated destructor is fine for non-base
  // classes without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  trackMetrics(trackMetrics const&) = delete;
  trackMetrics(trackMetrics&&) = delete;
  trackMetrics& operator=(trackMetrics const&) = delete;
  trackMetrics& operator=(trackMetrics&&) = delete;

  // Required functions.
  void analyze(art::Event const& e) override;

  // Selected optional functions.
  void beginJob() override;
  void endJob() override;

private:

  // Declare member data here.
  TTree *fTree;
  TH1D *fTrackCRPsize_Plane0;
  TH1D *fTrackCRPsize_Plane1;
  TH1D *fTrackCRPsize_Plane2;
  TH2D *fTrackCRPs2D;
  TH2D *fTrackHitFractionCRPs;
  TH1D *fTrackHitFractionCRP0;
  TH1D *fTrackHitFractionCRP1;

  unsigned int fEventID;
  unsigned int fRunID;
  unsigned int fSubRunID;
  std::vector<std::vector<unsigned int>> *fTrackHitsTPCs_Plane0;
  std::vector<std::vector<unsigned int>> *fTrackHitsTPCs_Plane1;
  std::vector<std::vector<unsigned int>> *fTrackHitsTPCs_Plane2;
  std::vector<std::vector<unsigned int>> *fTrackHitsTPCcounts_Plane0;
  std::vector<std::vector<unsigned int>> *fTrackHitsTPCcounts_Plane1;
  std::vector<std::vector<unsigned int>> *fTrackHitsTPCcounts_Plane2;
  std::vector<double> *fTrackCharge_Plane0;
  std::vector<double> *fTrackCharge_Plane1;
  std::vector<double> *fTrackChargeAsym;
  std::string fPFParticleLabel;
  std::string fTrackLabel;
  const geo::Geometry* fGeom;
};


test::trackMetrics::trackMetrics(fhicl::ParameterSet const& p)
  : EDAnalyzer{p} ,
    fTrackHitsTPCs_Plane0(nullptr),
    fTrackHitsTPCs_Plane1(nullptr),
    fTrackHitsTPCs_Plane2(nullptr),
    fTrackHitsTPCcounts_Plane0(nullptr),
    fTrackHitsTPCcounts_Plane1(nullptr),
    fTrackHitsTPCcounts_Plane2(nullptr),
    fTrackCharge_Plane0(nullptr),
    fTrackCharge_Plane1(nullptr),
    fTrackChargeAsym(nullptr)
{
  fPFParticleLabel = p.get<std::string>("PFParticleLabel");
  fTrackLabel = p.get<std::string>("TrackLabel");
  fGeom    = &*art::ServiceHandle<geo::Geometry>();
}

void test::trackMetrics::analyze(art::Event const& e)
{

  fEventID = e.id().event();
  fRunID = e.id().run();
  fSubRunID = e.id().subRun();
  fTrackHitsTPCs_Plane0->clear();
  fTrackHitsTPCs_Plane1->clear();
  fTrackHitsTPCs_Plane2->clear();
  fTrackHitsTPCcounts_Plane0->clear();
  fTrackHitsTPCcounts_Plane1->clear();
  fTrackHitsTPCcounts_Plane2->clear();
  fTrackCharge_Plane0->clear();
  fTrackCharge_Plane1->clear();
  fTrackChargeAsym->clear();
  
  std::cout << "== EVENT " << fEventID <<" == RUN " << fRunID << " == SUBRUN " << fSubRunID << "=============================" << std::endl;

  //Access the PFParticles from Pandora
  art::Handle<std::vector<recob::PFParticle>> pfparticleHandle;
  std::vector<art::Ptr<recob::PFParticle>> pfparticleVect;
  if (e.getByLabel(fPFParticleLabel,pfparticleHandle)) //make sure the handle is valid
    art::fill_ptr_vector(pfparticleVect,pfparticleHandle); //fill the vector with art::Ptr PFParticles

  //Access the Tracks from pandoraTrack
  art::Handle<std::vector<recob::Track>> trackHandle;
  std::vector<art::Ptr<recob::Track>> trackVect;
  if (e.getByLabel(fTrackLabel,trackHandle)) //make sure the handle is valid
    art::fill_ptr_vector(trackVect,trackHandle); //fill the vector with art::Ptr PFParticles
  art::FindManyP<recob::Track> trackAssoc(pfparticleVect, e, fTrackLabel);

  //Loop over the PFPs
  int iPfp(0);
  std::cout << "Npfps in event = " << pfparticleVect.size() << std::endl;
  for(const art::Ptr<recob::PFParticle> &pfp: pfparticleVect){
    std::cout <<"-- PFP " << iPfp << " --------------------------------------" <<std::endl;

    std::vector<art::Ptr<recob::Track>> pfpTracks = trackAssoc.at(pfp.key());    
    std::vector<unsigned int> trkHitsTPCs_Plane0,trkHitsTPCs_Plane1,trkHitsTPCs_Plane2, trkHitsTPCs_thisPlane, trkHitsTPCcounts_thisPlane, totalhits;
    std::vector<unsigned int> trkHitsTPCcounts_Plane0,trkHitsTPCcounts_Plane1,trkHitsTPCcounts_Plane2;
    float trkCharge_plane0(0), trkCharge_plane1(0);
    //std::cout << "pfpTracks = " << pfpTracks.size() << std::endl;
    if(!pfpTracks.empty()){
      int iTrk(0);
      //Loop over the tracks associated with each PFP
      std::cout << "Pfp n. " << iPfp << "n tracks = " << pfpTracks.size() << std::endl;
      for(const art::Ptr<recob::Track> &trk:pfpTracks){
        std::cout << "-- TRK " << iTrk << " ----------" << std::endl;
	iTrk++;

        std::vector<unsigned> hitsTpcId( fGeom->Nplanes() );
        //Loop over the planes 
        for(size_t i_plane = 0; i_plane<fGeom->Nplanes(); i_plane++) {
          std::cout << "-- PLANE " << i_plane << " ------" << std::endl;
          std::vector<const recob::Hit*> trackHits;
          auto recoTracks = e.getValidHandle<std::vector<recob::Track> >(fTrackLabel);
          art::FindManyP<recob::Hit> findHits(recoTracks,e,fTrackLabel);
          std::vector<art::Ptr<recob::Hit>> inputHits = findHits.at(trk->ID());
  
	  //Exclude hits that are not in this plane (sanity check) 
          for(const art::Ptr<recob::Hit> hit : inputHits){
            unsigned int thePlane = hit.get()->WireID().asPlaneID().Plane;
            if( thePlane != i_plane ) continue;
            trackHits.push_back(hit.get());
          }

	  //Define TPC ID vector which will have an entry for every hit
          std::vector<int> plane_hits_tpcid( trackHits.size() );
         
          std::cout << " iPfp = " << iPfp << " iTrk = " << iTrk << " i_plane " << i_plane << std::endl;
          //Loop over hits and save TPC ID for each of them
          for(unsigned int i_hit = 0; i_hit<trackHits.size(); i_hit++ ){
            plane_hits_tpcid[i_hit] = int(trackHits[i_hit]->WireID().TPC);
	    //Add hit charge to total track charge for the plane of interest
            if(i_plane==0)trkCharge_plane0 += trackHits[i_hit]->SummedADC();
	    else if(i_plane==1)trkCharge_plane1 += trackHits[i_hit]->SummedADC();
          }

	  //Loop over TPC vector and fill two new vectors for this plane:
	  //one for the non-repeating TPC IDs for this plane, and one of equal size for the number of hits in each
	  std::sort(plane_hits_tpcid.begin(), plane_hits_tpcid.end()); 
	  int occurrences(0), tpcID(-1);
          for(auto it : plane_hits_tpcid){
            if(it!=tpcID){
	      tpcID=it;
	      //occurrences = std::count(plane_hits_tpcid.begin(), plane_hits_tpcid.end(), it) -1;
	      occurrences = std::count(plane_hits_tpcid.begin(), plane_hits_tpcid.end(), it);
              std::cout << "CRP = " << it << " occurrences = " << occurrences << std::endl; 
              if(i_plane==0)trkHitsTPCs_Plane0.push_back(it);
              else if(i_plane==1)trkHitsTPCs_Plane1.push_back(it);
              else if(i_plane==2)trkHitsTPCs_Plane2.push_back(it);
              trkHitsTPCs_thisPlane.push_back(it);
              trkHitsTPCcounts_thisPlane.push_back(occurrences);
              if(i_plane==0)trkHitsTPCcounts_Plane0.push_back(occurrences);
              else if(i_plane==1)trkHitsTPCcounts_Plane1.push_back(occurrences);
              else if(i_plane==2)trkHitsTPCcounts_Plane2.push_back(occurrences);
	    }
	  }

	  //Determine fraction of hits from each CRP, in the current plane, and fill related 2D histo
	  double fraction_crp1(0); 
	  double fraction_crp3(0);
	  double fraction_crp2(0);
	  double totalhits(0);
	  for(unsigned int iTPC=0; iTPC<trkHitsTPCs_thisPlane.size(); iTPC++){
	    if(trkHitsTPCs_thisPlane.at(iTPC)==1) fraction_crp1 += trkHitsTPCcounts_thisPlane.at(iTPC);
	    else if(trkHitsTPCs_thisPlane.at(iTPC)==3) fraction_crp3 += trkHitsTPCcounts_thisPlane.at(iTPC);
	    else if(trkHitsTPCs_thisPlane.at(iTPC)==2) fraction_crp2 += trkHitsTPCcounts_thisPlane.at(iTPC);
            totalhits+=trkHitsTPCcounts_thisPlane.at(iTPC);
 	  }
	  std::cout << "hits in CRP1 = " << fraction_crp1 << " hits in CRP2 = " << fraction_crp2 << " hits in CRP3 = " << fraction_crp3 << " total hits = " << totalhits << std::endl;
          fraction_crp1=fraction_crp1/totalhits;
          fraction_crp3=fraction_crp3/totalhits;
          //if(fraction_crp1+fraction_crp3!=1) std::cout << "Something's wrong! fraction_crp1 + fraction_crp3 != 1" << std::endl;
          //std::cout << "fraction_crp1 = " << fraction_crp1 << std::endl;
          //std::cout << "fraction_crp3 = " << fraction_crp3 << std::endl;
	  fTrackHitFractionCRPs->Fill(fraction_crp1,fraction_crp3);
	  fTrackHitFractionCRP0->Fill(fraction_crp1);
	  fTrackHitFractionCRP1->Fill(fraction_crp3);

          trkHitsTPCs_thisPlane.clear();
          trkHitsTPCcounts_thisPlane.clear();
        }

        // charge asymmetrharge_plane0
	fTrackCharge_Plane0->push_back(trkCharge_plane0);
	fTrackCharge_Plane1->push_back(trkCharge_plane1);
        fTrackChargeAsym->push_back((trkCharge_plane0 - trkCharge_plane1)/(trkCharge_plane0+ trkCharge_plane1));	

	//Fill tree branches with the vectors filled above, for each plane
        fTrackHitsTPCs_Plane0->push_back(trkHitsTPCs_Plane0);
        fTrackHitsTPCs_Plane1->push_back(trkHitsTPCs_Plane1);
        fTrackHitsTPCs_Plane2->push_back(trkHitsTPCs_Plane2);
        fTrackHitsTPCcounts_Plane0->push_back(trkHitsTPCcounts_Plane0);
        fTrackHitsTPCcounts_Plane1->push_back(trkHitsTPCcounts_Plane1);
        fTrackHitsTPCcounts_Plane2->push_back(trkHitsTPCcounts_Plane2);
	
	//Draw histograms for each plane: number of TPCs per track, same with a 5 and 10 hits threshold for each TPC
	fTrackCRPsize_Plane0->Fill(trkHitsTPCs_Plane0.size());
	fTrackCRPsize_Plane1->Fill(trkHitsTPCs_Plane1.size());
	fTrackCRPsize_Plane2->Fill(trkHitsTPCs_Plane2.size());

        int iCRPPlane0(0), iCRPPlane1(0); bool fillHisto(true);
	//std::cout << " trkHitsTPCs_Plane0.size() = " << trkHitsTPCs_Plane0.size() << std::endl;
	//std::cout << " trkHitsTPCs_Plane1.size() = " << trkHitsTPCs_Plane1.size() << std::endl;
        //if(trkHitsTPCs_Plane0.size()==1) std::cout << "debug: trkHitsTPCs_Plane0.at(0) = " << trkHitsTPCs_Plane0.at(0) << std::endl;
        //if(trkHitsTPCs_Plane1.size()==1) std::cout << "debug: trkHitsTPCs_Plane1.at(0) = " << trkHitsTPCs_Plane1.at(0) << std::endl;

       
        if(trkHitsTPCs_Plane0.size()==2 && trkHitsTPCs_Plane0.at(0)!=2 && trkHitsTPCs_Plane0.at(1)!=2)iCRPPlane0=2;
        else if(trkHitsTPCs_Plane0.size()==1 && trkHitsTPCs_Plane0.at(0)==1) iCRPPlane0=0;
        else if(trkHitsTPCs_Plane0.size()==1 && trkHitsTPCs_Plane0.at(0)==3) iCRPPlane0=1;
	else fillHisto=false;
        //else std::cout << "debug: trkHitsTPCs_Plane0.at(0) = " << trkHitsTPCs_Plane0.at(0) << " trkHitsTPCs_Plane0.size() = " << trkHitsTPCs_Plane0.size() << std::endl;
        if(trkHitsTPCs_Plane1.size()==2 && trkHitsTPCs_Plane1.at(0)!=2 && trkHitsTPCs_Plane1.at(1)!=2)iCRPPlane1=2;
        else if(trkHitsTPCs_Plane1.size()==1 && trkHitsTPCs_Plane1.at(0)==1) iCRPPlane1=0;
        else if(trkHitsTPCs_Plane1.size()==1 && trkHitsTPCs_Plane1.at(0)==3) iCRPPlane1=1;
	else fillHisto=false;
        //else std::cout << "debug: trkHitsTPCs_Plane1.at(0) = " << trkHitsTPCs_Plane1.at(0) << " trkHitsTPCs_Plane0.size() = " << trkHitsTPCs_Plane0.size() << std::endl;
	if(fillHisto)fTrackCRPs2D->Fill(iCRPPlane0,iCRPPlane1);
	std::cout << "event ID = " << fEventID << std::endl;
	if(iCRPPlane0==0 && iCRPPlane1==1) std::cout << "found a particle with view 0 in CRP1 and view1 in CRP2 in ev. (num, subrun, run) " << fEventID << " " << fSubRunID << " " << fRunID << " iPfp = " << iPfp << std::endl;
	else if(iCRPPlane0==1 && iCRPPlane1==0) std::cout << "found a particle with view 0 in CRP2 and view1 in CRP1 in ev. (num, subrun, run) " << fEventID << " " << fSubRunID << " " << fRunID << " iPfp = " << iPfp << std::endl;
	else std::cout << "found no particles in different CRPs in different views! iPfp = " << iPfp << std::endl;

        trkHitsTPCs_Plane0.clear();
        trkHitsTPCs_Plane1.clear();
        trkHitsTPCs_Plane2.clear();
	trkHitsTPCcounts_Plane0.clear();
	trkHitsTPCcounts_Plane1.clear();
	trkHitsTPCcounts_Plane2.clear();
	trkCharge_plane0=0;
	trkCharge_plane1=0;
      }
    }

    //Read clusters information for this PFP
   /* std::vector<art::Ptr<recob::Hit>> pfpHits = dune_ana::DUNEAnaPFParticleUtils::GetHits(pfp,e,fPFParticleLabel);
   std::cout <<  "Now reading hits directly from PFP..." << std::endl;
   for(unsigned int i_hit = 0; i_hit<pfpHits.size(); i_hit++ ){
     std::cout << "plane " << pfpHits[i_hit]->WireID().asPlaneID().Plane << " WireID().TPC = " << pfpHits[i_hit]->WireID().TPC << std::endl;
   }*/

  }

  fTree->Fill();
}

void test::trackMetrics::beginJob()
{
  art::ServiceHandle<art::TFileService> tfs;
  fTree = tfs->make<TTree>("pandoraOutput","Pandora Output Tree");

  fTree->Branch("eventID",&fEventID,"eventID/i");
  fTree->Branch("trackHitsTPCs_Plane0",&fTrackHitsTPCs_Plane0);
  fTree->Branch("trackHitsTPCs_Plane1",&fTrackHitsTPCs_Plane1);
  fTree->Branch("trackHitsTPCs_Plane2",&fTrackHitsTPCs_Plane2);
  fTree->Branch("trackHitsTPCcounts_Plane0",&fTrackHitsTPCcounts_Plane0);
  fTree->Branch("trackHitsTPCcounts_Plane1",&fTrackHitsTPCcounts_Plane1);
  fTree->Branch("trackHitsTPCcounts_Plane2",&fTrackHitsTPCcounts_Plane2);
  fTree->Branch("trackChargeAsym", &fTrackChargeAsym);
  fTree->Branch("trackCharge_Plane0", &fTrackCharge_Plane0);
  fTree->Branch("trackCharge_Plane1", &fTrackCharge_Plane1);

  fTrackCRPsize_Plane0 = tfs->make<TH1D>("TrackCRPsize_Plane0","Number of Plane0 TPCs for hits in this track",5,0,5);
  fTrackCRPsize_Plane1 = tfs->make<TH1D>("TrackCRPsize_Plane1","Number of Plane1 TPCs for hits in this track",5,0,5);
  fTrackCRPsize_Plane2 = tfs->make<TH1D>("TrackCRPsize_Plane2","Number of Plane2 TPCs for hits in this track",5,0,5);

  fTrackCRPs2D = tfs->make<TH2D>("TrackCRPs2D","TrackCRPs2D",3,0,3,3,0,3);
  fTrackCRPs2D->GetXaxis()->SetTitle("View0 (0 = CRP1, 1 = CRP3, 2 = CRP1 and CRP3)");
  fTrackCRPs2D->GetYaxis()->SetTitle("View1");
  fTrackHitFractionCRPs = tfs->make<TH2D>("TrackHitFractionCRPs","TrackHitFractionCRPs",30,-0.1,1.1,30,-0.1,1.1);
  fTrackHitFractionCRPs->GetXaxis()->SetTitle("Fraction of hits in CRP1");
  fTrackHitFractionCRPs->GetYaxis()->SetTitle("Fraction of hits in CRP3");
  fTrackHitFractionCRP0 = tfs->make<TH1D>("TrackHitFractionCRP1","TrackHitFractionCRP1",30,-0.1,1.1);
  fTrackHitFractionCRP1 = tfs->make<TH1D>("TrackHitFractionCRP3","TrackHitFractionCRP3",30,-0.1,1.1);
}

void test::trackMetrics::endJob()
{
}

DEFINE_ART_MODULE(test::trackMetrics)
